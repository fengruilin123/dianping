---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by rlfeng.
--- DateTime: 2024/7/9 15:56
---
local key = KEYS[1]
local bucketMaxTokens = tonumber(ARGV[1])
local intervalPerTokens = tonumber(ARGV[2])
local resetBucketInterval = tonumber(ARGV[3])
local bucket = redis.call('hgetall', key);
local currentTokens=0
local curr_time_arr = redis.call('time')
local currTime = curr_time_arr[1]*1000 + math.floor(curr_time_arr[2]/1000)

--若当前桶未初始化，则初始化桶
if table.maxn(bucket)==0 then
    --初始桶内令牌数
    currentTokens = bucketMaxTokens
    redis.call('hset', key, 'lastRefillTime', currTime)
    redis.call('pexpire', key, resetBucketInterval * 150)
--若桶已经初始化，则计算桶内令牌
elseif table.maxn(bucket) == 4 then
    local lastFillTime = tonumber(bucket[2])
    local remainingTokens = tonumber(bucket[4])
    if currTime > lastFillTime then
        --拿到当前与上一次更新的时间间隔:ms
        local itvTime = currTime - lastFillTime
        if itvTime > resetBucketInterval then
            currentTokens=bucketMaxTokens
            redis.call('hset', key, 'lastRefillTime', currTime)
        else
            local grantedTokens = math.floor(itvTime / intervalPerTokens)

            -- 可授予的令牌 > 0 时
            -- 举例理解 : grantedTokens = 620/200 = 3.1 = 3
            if grantedTokens > 0 then

                -- 生成的令牌 = 上次填充时间与当前时间的时间间隔 % 两个令牌许可之间的时间间隔
                -- 举例理解 : padMillis = 620%200 = 20
                --           curTime = 2620
                --           curTime - padMillis = 2600
                local padMillis = math.fmod(itvTime, intervalPerTokens)

                -- 将当前令牌桶更新到上一次生成时间
                redis.call('hset', key, 'lastRefillTime', currTime - padMillis)
            end

            -- 更新当前令牌桶中的令牌数
            -- Math.min(根据时间生成的令牌数 + 剩下的令牌数, 桶的限制) => 超出桶最大令牌的就丢弃
            currentTokens = math.min(grantedTokens + remainingTokens, bucketMaxTokens)
        end
    else
        currentTokens=remainingTokens
    end
end

-- 如果当前桶内令牌小于 0,抛出异常
assert(currentTokens >= 0)

-- 如果当前令牌 == 0 ,更新桶内令牌, 返回 0
if currentTokens == 0 then
    redis.call('hset', key, 'tokensRemaining', currentTokens)
    return 0
else
    -- 如果当前令牌 大于 0, 更新当前桶内的令牌 -1 , 再返回当前桶内令牌数
    redis.call('hset', key, 'tokensRemaining', currentTokens - 1)
    return currentTokens
end